%% Matlab Program to process I12 EDX timeseries data
% This program imports data from '.nxs' files generated by beamine I12
% at the Diamond Light Source, bins the detectors and generates
% time series data.
%
% I12 features 23 energy sensitive X-Ray detectors arranged in a
% semi-circular array. Each of these detectors must be individually
% interpolated, scaled and the resulting data summed together.


%% First clear all previous data and start program timer
clear
clf
tic


%% Define start and end files
% These values define the start and end run-numbers of the defined dataset.
% The varable _startf_ should be the first data collection of the run, this
% will define the start time of the series. The _finalf_ value can be any
% dataset, collected later than the first, while the data is collecting
% this will normally be the current dataset.

%Start and end files

 startf = 41613;
 finalf = 41690;


totalf = size(startf:1:finalf,2);

%% Define Q range to process
% These values define the start and end and intermediate Q values over
% which to process the data. The variable _qstart_ defines the first Q
% value to be reprocessed, while _qstop_ defines the final Q value.
% _qspace_ defines the spacing between Q values, allowing for fine or
% coarse data binning. These three variables define the range of _x_ to be
% used throughout the script.

%Q ranges
qstart = 1;
qstop  = 8;
qspace = 0.01;
x      = qstart:qspace:qstop;

%% Define file paths
% These variables define the locations of the raw data files in the
% computer's filesystem. The variable _path_ defines the absolute or
% relative location of the raw '.nxs' files are stored, the _nexus_
% variable then generates the filename of the first dataset to extract the
% intial conditions data. The _element_ and _instrument_ variables define
% data-trees within the '.nxs' file where the raw data is stored.

%Paths
path       = '/Users/mathew/Documents/MATLAB/NeXus/rawdata/';
nexus      = [path, num2str(startf) ,'.nxs'];
element    = '/entry1/instrument/EDXD_Element_01';
instrument = '/entry1/instrument';

%% Define time = 0 for the experiment
% The dataset defined by _startf_ defines time = 0 for the experiment,
% _h5read_ reads the time (in seconds) from this datafile and stores it in
% _st_ so it can be referenced later in the program.

%Start time
st = h5read(nexus,[instrument,'/actualTime/actualTime']);

%% Pre-allocation of arrays
% In order to speed up calculations, the size of output variables must be
% pre-defined before data is added in loops, this avoids re-sizing the
% variables once per loop.

%Preallocate arrays
y   = zeros(size(x,2),23);
out = cell(10,totalf);

%% Read raw '.nxs' data files
% The script now reads in the raw '.nxs' files generated by I12, in a loop
% from 1 to the total number of defined datasets.

%Read x,time and data to _out_ variable
for i = 1:1:totalf
    %%%
    % the variable _nexus_ is
    % updated once per loop to define the correct data file.
    nexus = [path, num2str(startf + i -1) ,'.nxs'];
    
    %% Read raw detector data
    % The script must now read the data from the individual detectors, in a
    % loop from detector 1 to 23. The variable _element_ defines the current
    % element as defined by the position within the loop. The variable _live_
    % defines the 'live' time of the detector, the length of time the
    % individual detector was active. The variables _q_ and _data_ define the
    % collected data. Due to differences in alignment, each detector has
    % slightly different values of Q, so all detectors must be interploated to
    % a constant _x_ range as defined in the 'Define Q range' section above.
    % These interpolated values are then input into the _y_ output matrix in
    % column number consecuative with the detector number.
    
    %Collect raw detector data
    for k = 1:1:23
        %Define NeXus path
        element  = ['/entry1/instrument/EDXD_Element_', num2str(k,'%02i')];
        %Determine detector live time
        live     = h5read(nexus,[element, '/edxd_energy_live_time']);
        %Read daw data and scale to detector live time
        q        = h5read(nexus,[element, '/edxd_q']);
        data     = h5read(nexus,[element, '/data'])/live;
        %Interpolate to constant Q
        inter    = interp1(q,data,x);
        y(:,1) = inter;
        
    end
    
  
    
    %% Write extracted data into the _out_ variable
    % The script must then output the combined data to the _out_ variable,
    % the main data store for the script.
    %
    % * Row 1 is the I12 dataset number
    % * Row 2 is the sum of the 23 detectors
    % * Row 3 is the _x_ position of the motorised sample table
    % * Row 4 is the _y_ position of the motorised sample table
    % * Row 5 is the start time of the data collection in relation to the
    % start time of the first dataset
    % * Row 6 is the live time of the first detector
    % * Row 7 is the interpolated, unsummed data from the 23 detectors
    %
    out{1,i} = startf + i -1;
    out{2,i} = sum(y,2);
    out{3,i} = h5read(nexus,[instrument,...
        '/ss2/ss2_x']);
    out{4,i} = h5read(nexus,[instrument,...
        '/ss2/ss2_y']);
    out{5,i} = h5read(nexus,[instrument,...
        '/actualTime/actualTime']) -st;
    out{6,i} = h5read(nexus,[instrument,...
        '/EDXD_Element_01/edxd_trigger_live_time']);
    out{7,i} = y;
    out{9,i} = h5read(nexus,[instrument,...
        '/source/current']);
    out{10,i} = h5read(nexus,[instrument,...
        '/source/energy']);
     out{11,i} = sum(y,2)/(out{9,i}*out{10,i});
    
    %%%
    % End the '.nxs' data import loop
end

%% Organise dataset _xy_ data into discreet positions
% The script must then assign each dataset a unique value based upon it's
% xy postition on the sample table, first the script must read in the _xy_
% positions from the data outputted by the previous section and generate an
% xy matrix.

%Create matrix of xy positions
xy = zeros(size(out,2),2);
for i = 1:1:size(out,2)
    xx = out{3,i};
    y = out{4,i};
    
    xy(i,:) = [xx y];
end

%%%
% The xy values are then rounded to compensate for inaccuracies in table
% positioning, and the total number of unique xy positions are defined in
% the variable _xy_.

xy = round(xy);
xy = unique(xy,'rows');

%%%
% The rounded xy values for each dataset are then compared to the _xy_
% variable defining the total unique xy positions. The matching row number
% is then recorded in row 8 of the data output variable.

%Add site descriptors for each unique xy value
for i = 1:1:size(out,2)
    pos = [round(out{3,i}) round(out{4,i})];
    for j  = 1:1:size(xy,1)
        if pos == xy(j,:)
            out{8,i} = j;
        end
    end
end

%% Plot output
% The output for the individual xy positions are plotted in thier
% respective groups. The _cc_ variable defines the _colorbrewer_ colormap
% for the plots, offset by the collection time.

%Plot output
cc = cbrewer('div', 'RdYlGn', size(out,2));
for i = 1:1:size(out,2)
    for j = 1:1:size(xy,1)
        if out{8,i} == j
            hold on
            figure(1)
            subplot(1,3,j)
            plot(x,out{2,i}(:,1),'color',cc(i,:))
            xlim([qstart,qstop]);
            title(['Sample position ' num2str(j)]);
        end
    end
end

%% Create waterfall plot of one unique _xy_ position
I12water(x,out,3)

%% End program timer and display total elapsed time
toc
